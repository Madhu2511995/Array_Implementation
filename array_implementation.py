# -*- coding: utf-8 -*-
"""Array_Implementation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D3uJpP6SQcMDXsBBJviHdQuJwDcSGVnR

# **Largest Element In an array**
"""

# Method 1
arr=[1,3,4,7,7,5]
arr.sort()
print(arr[len(arr)-1])

# Method 2
arr=[1,3,4,7,7,5]
largest=0
for i in range(len(arr)):
  if arr[i]>largest:
    largest=arr[i]
print(largest)

"""# **Second Largest Element**"""

# Method 1
arr=[1,3,4,7,7,5]
arr.sort()
largest=arr[len(arr)-1]
for i in range(len(arr)-1,0,-1):
  if largest!=arr[i]:
    print(arr[i])
    break

# Method 2
arr=[1,3,4,7,7,5]
largest=arr[0]
for i in range(len(arr)):
  if arr[i]>largest:
    largest=arr[i]
slargest=-1
for j in range(len(arr)):
  if arr[j]>slargest and arr[j]!=largest:
    slargest=arr[j]
print(slargest)

# Method 3
import math
arr=[1,3,4,7,7,5]
l=arr[0]
sl=-1
for i in range(len(arr)):
  if arr[i]>l:
    sl=l
    l=arr[i]
  elif arr[i]<l and arr[i]>sl:
    sl=arr[i]
print(sl)

import math
arr=[1,3,4,7,7,5]
f_max=-math.inf
s_max=-math.inf
arr.sort()
for i in range(len(arr)):
  if f_max<=i:
    s_max=f_max
    f_max=arr[i]
  elif s_max<i and f_max<i:
    s_max=arr[i]
print(s_max)

"""# **Smallest and second smallest**"""

import math
arr=[1,3,4,7,7,5]
smallest=math.inf
secondsmallest=math.inf
for i in range(len(arr)):
  if arr[i]<smallest:
    secondsmallest=smallest
    smallest=arr[i]
  elif arr[i]!=smallest and arr[i]<secondsmallest:
    secondsmallest=arr[i]
print("Smallest Value : ",smallest)
print("Second Smallest Value : ",secondsmallest)

"""# **Check Is array sorted**"""

arr=[1,3,4,7,5]
for i in range(1,len(arr)):
  if arr[i]>=arr[i-1]:
    pass
  else:
    print("Not sorted")
    break
else:
  print('Sorted')

"""# **Remove duplicate from sorted array**"""

l=["flight","flower",'fear','flow']
new_s=l[0]
size=[]
res=''
for  i in  l:
    size.append(len(i))
for i in range(min(size)):
    count=0
    for s in l:
        if new_s[i] == s[i]:
            count+=1
    if count==len(l):
        res+=s[i]
print(res)

l=[1,1,2,2,3,3,3,4]
s=set()
for i in range(len(l)):
  s.add(l[i])
print(s)

# Count the number of unique element
l=[1,1,1,1,2,2,2,3,3,3,3,4,5,5,5,5,7]
arr=[]
i=0
arr.append(l[0])
for j in range(0,len(l)):
  if l[j]!=l[i]:
    arr.append(l[j])
    l[i+1]=l[j]
    i+=1
print(arr)

arr=[1,1,1,1,2,2,2,3,3,3,3,4]
i=0
l=[]
for j in range(len(arr)):
  if arr[i]!=arr[j]:
    l.append(arr[i])
  i+=1
print(l)

"""# **Left Rotate Array by one place**"""

arr=[1,2,3,4,5]
temp=arr[0]
for i in range(1,len(arr)):
  arr[i-1]=arr[i]
arr[len(arr)-1]=temp
print(arr)

#Method 2
d=int(input())
arr=[1,2,3,4,5]
l=[]
n=len(arr)
d=d%n # it work when d value is gretter than lenth of array
for i in range(d,n):
  l.append(arr[i])
for i in range(d):
  l.append(arr[i])
print(l)

# Method 2 Using reverse function
def rev(arr,s=0,e=len(arr)-1):
  while s<=e:
    temp=arr[s]
    arr[s]=arr[e]
    arr[e]=temp
    s+=1
    e-=1
  return arr
d=int(input())
arr=[1,2,3,4,5]
n=len(arr)
d=d%n
rev(arr,0,d-1)
rev(arr,d,n-1)
rev(arr,0,n-1)

"""# **Right Rotate array d places**"""

d=int(input())
arr=[1,2,3,4,5]
l=[]
m=[]
n=len(arr)
d=d%len(arr)
for i in range(n-d,n):
  l.append(arr[i])
for j in range(n-d):
  l.append(arr[j])
print(l)

"""# **Moving all zero to last of array**"""

# Method 1
arr=[1,2,0,2,3,0,0,1,2]
l=[]
l1=[]
for i in range(len(arr)):
  if arr[i]==0:
    l1.append(arr[i])
  else:
    l.append(arr[i])
l.extend(l1)
print(l)

# Method 2
from pandas.core.common import flatten
arr=[1,2,0,2,3,0,0,1,2]
l=[]
l1=[]
for i in range(len(arr)):
  if arr[i]==0:
    l1.append(arr[i])
  else:
    l.append(arr[i])
l.append(l1)
print(list(flatten(l)))

# Method 3
arr=[1,2,0,2,3,0,0,1,2]
j=-1
for i in range(len(arr)):
  if arr[i]==0:
    j=i
    break
if j==-1:
  print(arr)
for i in range(j+1,len(arr)):
  if arr[i]!=0:
    temp=arr[i]
    arr[i]=arr[j]
    arr[j]=temp
    j+=1
print(arr)

"""# **Union of two array**"""

# Method 1
l=[1,1,2,3,4,5,1]
m=[2,2,3,4,6]
u=set()
for i in l:
  u.add(i)
for j in m:
  u.add(j)
print(u)

l=[1,1,2,3,4,5,1]
m=[2,2,3,4,6]
l=set(l)
m=set(m)
print(l.union(m))
print(l.intersection(m))

"""# **Intersection of two array**"""

# Method 1
l=[1,1,2,3,4,5,1]
m=[2,2,3,4,6]
l=set(l)
m=set(m)
print(l.intersection(m))

#Method 2
l=[1,1,2,3,4,5]
m=[1,1,2,2,3,3,3,4]
visit=[]
for i in range(len(m)):
  visit.append(0)
n1=len(l)
n2=len(m)
min_len=n1
inter=[]
if n2<n1:
  min_len=n2
for i in range(n1):
  for j in range(n2):
    if l[i]==m[j] and visit[j]==0:
      inter.append(m[j])
      visit[j]==1
      break
  if m[j]>l[i]:
    break
print(inter)

# Method 3
A=[1,1,2,3,3,4,5]
B=[1,1,2,2,3,3,3,4]
n=len(A)
m=len(B)
i=0
j=0
ans=[]
while(i<n and j<m):
  if A[i]<B[j]:
    i+=1
  elif B[j]<A[i]:
    j+=1
  else:
    ans.append(A[i])
    i+=1
    j+=1
print(ans)

"""# **Find the missing number in given array**"""

# Method 1
n=int(input("max number : "))
arr=[1,2,4,5]
for i in range(1,n+1):
  if i in arr:
    pass
  else:
    print(i)

# Method 2
# Using Has concept
n=int(input("Enter Max Number : "))
arr=[1,2,3,4]
d={}
for i in range(n+1):
  d[i]=0
for i in range(len(arr)):
  d[arr[i]]=1
for j in range(1,n+1):
  if d[j]==0:
    print(j)
print(d)

# Method 3
# Optimal solution
n=int(input("Enter Max Number : "))
arr=[1,2,3,4]
sum=n*(n+1)/2
s=0
for i in range(len(arr)):
  s+=arr[i]
print("Missing Number is : ",sum-s)

# Method 4
# Optimal solution
n=int(input("Enter Max Number : "))
arr=[1,2,4,5]
xor1=0
for i in range(len(arr)):
  xor1=xor1^arr[i]
xor2=0
for j in range(1,n+1):
  xor2=xor2^j
print(xor1^xor2)

# Method 5
# optimal solution
n=int(input("Enter Max Number : "))
arr=[1,2,4,5]
xor1=0
xor2=0
for i in range(len(arr)):
  xor1=xor1^arr[i]
  xor2=xor2^(i+1)
xor2=xor2^n
print(xor1^xor2)

"""# **Maximun Consecutive Ones**"""

arr=[1,1,0,1,1,1,0,1,1]
d={}
for i in range(len(arr)):
  if arr[i] not in d:
    d[arr[i]]=1
  else:
     d[arr[i]]+=1
print(d)

arr=[1,1,0,1,1,1,0,1,1]
count=0
m=0
for i in range(len(arr)):
  if arr[i]==1:
    count+=1
    m=m if m>count else count
  else:
    count=0
print(m)

arr=[1,1,0,1,1,1,0,1,1]
count=0
m=[]
for i in range(len(arr)):
  if arr[i]==1:
    count+=1
    m.append(count)
  else:
    count=0
print(max(m))

"""# **Find that number which occures only ones**"""

# Brute TC O(n**2)
arr=[1,1,2,2,3,3,4,4,5]
for i in range(len(arr)):
  num=arr[i]
  count=0
  for j in range(len(arr)):
    if num==arr[j]:
      count+=1
  if count==1:
    print(num)

# Better using hassing TC O(2n)
arr=[1,1,2,2,3,3,4,4,5]
m=max(arr)
d={}
for i in range(1,m+1):
  d[i]=0
for i in range(len(arr)):
  d[arr[i]]+=1
if d[arr[i]]==1:
  print(arr[i])

# Optimal
# TC O(n)
arr=[1,1,2,3,3,4,4]
xor=0
for i in range(len(arr)):
  xor=xor^arr[i]
print(xor)

"""# **Two Sum Problem**"""

# Method 1
# TC O(n^2)
arr=[2,6,5,8,11]
n=int(input("Enter the to find if sum of two number is possible : "))
sum=0
for i in range(len(arr)):
  for j in range(len(arr)):
    if i==j:
      pass
    if arr[i]+arr[j]==n:
      print("yes")
      break
    else:
      pass

# Method 2 use Has Map
#TC : O(nlog(n))
arr=[2,6,5,8,11]
n=int(input("Enter the to find if sum of two number is possible : "))
d={}
for i in range(len(arr)):
  a=arr[i]
  more=n-a
  d[a]=i
  if more in d:
    print('yes')
    print(d[more],i) # return the index value of the number which sum is equal to given number.
    break
else:
  print('No')

# Same method like above without using map
arr=[2,6,5,8,11]
n=int(input("Enter the to find if sum of two number is possible : "))
res='No'
for i in arr:
  if n - i in arr:
    res='Yes'
    break
print(res)

#Method 3
arr=[2,6,5,8,11]
n=int(input("Enter the to find if sum of two number is possible : "))
arr.sort()
left=0
right=len(arr)-1
while left<right:
  sum=arr[left]+arr[right]
  if sum==n:
    print("Yes")
    print(left,right)
    break
  elif sum<n:
    left+=1
  else:
    right-=1
else:
  print("No")

s="Interview"
s=s.lower()
d={}
for i in s:
  if i not in d:
    d[i]=1
  else:
    d[i]+=1
for k,v in d.items():
  if v ==2:
    print(k)
    break

Keymax = max(d, key= lambda x: d[x])
print(Keymax)

max_key = next(iter(d))
# Iterate over the keys in the dictionary
for key in d:
    # If the value of the current key is greater than the value of max_key, update max_key
    if d[key] > d[max_key]:
        max_key = key

# Print the key with the maximum value
print(max_key)

s="banshbahadurpatel"
result=[]
temp_s=''
for i in s:
  if i in temp_s:
    result.append(temp_s)
    temp_s=i
  else:
    temp_s+=i
print(max(result))
print(result)

"""# **Sort an array of 0's 1's & 2's**"""

# Method 1
#TC O(n^2)
arr=[0,1,2,2,0,1,0]
n=len(arr)
for i in range(n):
  min=i
  for j in range(i+1,n):
    if arr[min]>arr[j]:
      min=j
    temp=arr[min]
    arr[min]=arr[i]
    arr[i]=temp
print(arr)

"""**# Dutch National flag Algorithem**"""

# Method 3 optimal
# Dutch National flag Algorithem
#TC O(n)
arr=[0,1,2,0,1,0,2,2,2,1,1,1,0,0,0]
n=len(arr)
low=0
mid=0
high=n-1
while mid<=high:
  if arr[mid]==0:
    temp=arr[low]
    arr[low]=arr[mid]
    arr[mid]=temp
    low+=1
    mid+=1
  elif arr[mid]==1:
    mid+=1
  else:
    temp=arr[mid]
    arr[mid]=arr[high]
    arr[high]=temp
    high-=1
print(arr)

"""# **Majority Element Gratter or equal to n/2**"""

# Method 1
# TC O(n^2)
arr=[2,2,3,3,1,2,2,1,3,3,3]
n=len(arr)
for i in range(n):
  count=0
  for j in range(n):
    if arr[i]==arr[j]:
      count+=1
if count>=n//2:
  print(arr[i])
else:
  print("None")

# Method 2 Use of has
# TC O(nlog(n))+ O(n)
arr=[2,2,3,3,1,2,2,1,3,3,3]
n=len(arr)
d={}
for i in arr:
  if i not in d:
    d[i]=1
  else:
    d[i]+=1
for k,v in d.items():
  if v>=n//2:
    print(k)

"""**# Moore's Voting Algorithm**"""

# Method 3
# Moore's Voting Algorithm
# TC : O(n)+O(n)
arr=[2,2,3,3,1,2,2,1,3,3,3]
n=len(arr)
count=0
for i in range(n):
  if count==0:
    ele=arr[i]
  elif arr[i]==ele:
    count+=1
  else:
    count-=1
count1=0
for i in range(n):
  if arr[i]==ele:
    count1+=1
if count1>=n//2:
  print(ele)
else:
  print("None")

"""# **Maximum Subarray Sum**"""

#Method 1 Maximum Sum of sub array
# TC O(n^3)

import math
arr=[-2,-3,4,-1,-2,1,5,-3]
n=len(arr)
result=[]
m=-math.inf
for i in range(n):
  for j in range(i,n):
    sum=0
    for k in range(i,j+1):
      sum+=arr[k]
      result.append(sum)
print(max(result))

#Method 2
# TC O(n^2)
arr=[-2,-3,4,-1,-2,1,5,-3]
n=len(arr)
result=[]
for i in range(n):
  sum=0
  for j in range(i,n):
    sum+=arr[j]
    result.append(sum)
print(max(result))

"""**Kadane's Algorithm**"""

# Method 1
# TC O(n), SC:O(1)
# Kadane's Algorithm
import math
arr=[-2,-3,4,-1,-2,1,5,-3]
n=len(arr)
sum=0
maxi=-math.inf
for i in range(n):
  sum+=arr[i]
  if sum>maxi:
    maxi=sum
  elif sum<0:
    sum=0
else:
  print(maxi)

# Print Subarray also
# TC O(n), SC:O(1)
# Kadane's Algorithm
import math
arr=[-2,-3,4,-1,-2,1,5,-3]
n=len(arr)
sum=0
maxi=-math.inf
start_i=-1
end_i=-1
for i in range(n):
  sum+=arr[i]
  if sum==0:
    start=i
  if sum>maxi:
    maxi=sum
    start_i=start
    end_i=i
  elif sum<0:
    sum=0
else:
  print(maxi)
print("Subarray index Number is : ",start_i,end_i)
print("Sub array is : ",arr[start_i:end_i+1])

# Subarray problem type 2
arr=[1,2,1,3,2]
n=len(arr)
m=2
d=3
count=0
for i in range(n-m+1):
  sum=0
  for j in range(i,m+i):
    sum+=arr[j]
  if sum==d:
    count+=1
print("Count",count)

"""# **Rearrange Array Elements by Sign**"""

# Method 1 Positive and Negative element are equal
# TC: O(n)+O(n/2)
# SC: O(n)
arr=[3,1,-2,-5,2,-4]
n=len(arr)
pos=[]
neg=[]
for i in range(n):
  if arr[i]>=0:
    pos.append(arr[i])
  else:
    neg.append(arr[i])
for i in range(n//2):
  arr[i*2]=pos[i]
  arr[i*2+1]=neg[i]
print(arr)

# Method 2
# TC: O(n)
# SC: O(n)
arr=[3,1,-2,-5,2,-4]
n=len(arr)
result=[]
pos_index=0
neg_index=1
for i in range(n):
  if arr[i]>0:
    result.insert(pos_index,arr[i])
    pos_index+=2
  else:
    result.insert(neg_index,arr[i])
    neg_index+=2
print(result)

# Method 1 Positive and Negative element are not equal
# TC: O(n)+O(n)
# SC: O(n)
arr=[-1,2,3,4,-3,1]
n=len(arr)
pos=[]
neg=[]
res=[]
for i in range(n):
  if arr[i]>0:
    pos.append(arr[i])
  else:
    neg.append(arr[i])
if len(pos)>len(neg):
  for i in range(len(neg)):
    res.insert(i*2,pos[i])
    res.insert(i*2+1,neg[i])
  remain_ele=len(neg)*2
  for i in range(len(neg),len(pos)):
    res.insert(remain_ele,pos[i])
    remain_ele+=1
else:
  for i in range(len(pos)):
    res.insert(i*2,pos[i])
    res.insert(i*2+1,neg[i])
  remain_ele=len(pos)*2
  for i in range(len(pos),len(neg)):
    res.insert(remain_ele,neg[i])
    remain_ele+=1
print(res)

"""# **Leaders in an Array**

Every element from right is smaller than the current number
"""

# Method 1
# TC: O(n^2)
# SC: O(n)
arr=[10,22,12,3,0,6]
n=len(arr)
result=[]
for i in range(n):
   leader=True
   for j in range(i+1,n):
      if arr[j]>arr[i]:
         leader=False
         break
   if leader==True:
      result.append(arr[i])
print(result)

# Method 1
# TC: O(n)
# SC: O(n)
import math
arr=[10,22,12,3,0,6]
n=len(arr)
result=[]
maxi=-math.inf
for i in range(n-1,-1,-1):
  if arr[i]>maxi:
    result.append(arr[i])
  maxi=max(maxi,arr[i])
print(result)

"""# **Longest Consecutive Sequence**"""

# Method 1 Longest Consecutive Sequence means like This 1,2,3,4
#TC: O(n^2)
#SC: O(1)
def ls(arr,num):
  for i in arr:
    if num in arr:
      return True
  return False

arr=[102,4,100,1,101,3,2,1,1]
n=len(arr)
for i in range(n):
  count=1
  x=arr[i]
  while ls(arr,x+1)==True:
    count+=1
    x=x+1
print(count)

# Method 2
# TC : O(nlog(n))+O(n)
# SC:O(N)
import math
arr=[102,4,100,1,101,3,2,1,1,2,2,3,3,4]
n=len(arr)
arr.sort()
count=0
longest=1
last_smallest=-math.inf
for i in range(n):
  if arr[i]-1==last_smallest:
    count+=1
    last_smallest=arr[i]
  elif last_smallest!=arr[i]:
    count=1
    last_smallest=arr[i]
  longest=max(longest,count)
print(longest)

# Method 3
# TC :in best case:O(3n)
# SC:O(N)
longest=1
arr=[102,4,100,1,101,3,2,1,1,2,2,3,3,4]
set_arr=set(arr)
for i in set_arr:
  if i-1 in set_arr:
    count=1
    x=i
    while x in set_arr !=True:
      count+=1
      x+=1
    longest=max(longest,count)
print(longest)

"""# **Set Matrix Zeroes | O(1) Space Approach**"""

# Method 1
# TC :O(n^3)
# SC:O(1)
arr=[[1,1,1,1],
     [1,0,0,1],
     [1,1,0,1],
     [1,1,1,1]]
n=len(arr)
def makeRow(row):
  for col in range(n):
    if arr[row][col]!=0:
      arr[row][col]=-1
def makeCol(col):
  for row in range(n):
    if arr[row][col]!=0:
      arr[row][col]=-1

for row in range(n):
  for col in range(n):
    if arr[row][col]==0:
      makeRow(row)
      makeCol(col)

for i in range(n):
  for j in range(n):
    if arr[i][j]==-1:
      arr[i][j]=0
for i in arr:
  print(i)

# Method 1
# TC :O(n^2)
# SC:O(n)+O(m)

arr=[[1,1,1,1],
     [1,0,0,1],
     [1,1,0,1],
     [1,1,1,1]]
n=len(arr)
row = [0] * n  # row array
col = [0] * n
for i in range(n):
  for j in range(n):
    if arr[i][j]==0:
      row[i]=1
      col[j]=1

for i in range(n):
  for j in range(n):
    if row[i] or col[j]==1:
      arr[i][j]=0
for i in arr:
  print(i)

"""# **Rotate Matrix/Image by 90 Degrees**"""

# Method 1
# TC: O(n^2)
# SC: O(n^2)
arr=[[1,2,3,4],
     [5,6,7,8],
     [9,10,11,12],
     [13,14,15,16]]
n=len(arr)
ans=[[0]*4 for i in range(4)]
for row in range(n):
  for col in range(n):
    ans[col][n-row-1]=arr[row][col]
for i in ans:
  print(i)

# Method 2
# TC: O(n/2)*(n/2)+O(n/2)
# SC: O(1)
arr=[[1,2,3,4],
     [5,6,7,8],
     [9,10,11,12],
     [13,14,15,16]]
n=len(arr)
# Take transpose of matrix
for i in range(0,n-1):
  for j in range(i+1,n):
    temp=arr[i][j]
    arr[i][j]=arr[j][i]
    arr[j][i]=temp
# Take reverse
#res=[sorted(idx,reverse=True) for idx in arr]

# Another way to sort list of list
for i in arr:
  i.sort(reverse=True)

for i in arr:
  print(i)

"""# **Spiral Traversal of a Matrix | Spiral Matrix**"""

# Method 2
# TC: O(n*m)
# SC: O(n*m)
arr=[[1,2,3,4],
     [5,6,7,8],
     [9,10,11,12],
     [13,14,15,16]]
n=len(arr)
m=len(arr[0])
left=0
right=m-1
top=0
bottom=n-1
ans=[]
while top<=bottom and left<=right:
  # Right
  for i in range(left,right+1):
    ans.append(arr[top][i])
  top+=1
  #Top
  for i in range(top,bottom+1):
    ans.append(arr[i][right])
  right-=1
  #left
  if top<=bottom:
    for i in range(right,left-1,-1):
      ans.append(arr[bottom][i])
    bottom-=1
  # Bottom
  if left<=right:
    for i in range(bottom,top-1,-1):
      ans.append(arr[i][left])
    left+=1
for i in ans:
  print(i)

"""# **Count Subarray sum Equals K**
Contigous part of sub array
"""

# Method 1
# TC: O(n^3)
# SC: O(1)
arr=[1,2,3,-3,1,1,1,4,2,-3]
n=len(arr)
count=0
given_sum=3
for i in range(n):
  for j in range(i,n):
    sum=0
    for k in range(i,j+1):
      sum+=arr[k]
    if sum==given_sum:
      count+=1
print(count)

# Method 2
# TC: O(n^2)
# SC: O(1)
arr=[1,2,3,-3,1,1,1,4,2,-3]
n=len(arr)
count=0
given_sum=3
for i in range(n):
  sum=0
  for j in range(i,n):
    sum+=arr[j]
    if sum==given_sum:
      count+=1
print(count)

# Method 2
# TC: O(nlog(n))
# SC: O(n)
k = int(input('Input the number to find the sum: '))
arr = [1, 2, 3, -3, 1, 1, 1, 4, 2, -3]
n = len(arr)
d = {0: 1}
preSum = 0  # Initialize preSum to the value of arr[0]
count = 0
for i in range(n):
    preSum += arr[i]
    remove = preSum - k
    count += d.get(remove, 0)  # Use get() method to avoid KeyError
    d[preSum] = d.get(preSum, 0)+1
print(count)

"""# **Pascal Triangle | Finding nCr in minimal time**"""

# Type 1 Problem given row and col number find the value at the row and col value
# the we simple calculate (row-1) C (col-1)
# Like if row=6,and col=5 the calculate 5C4
def calnCr(n,r):
  num=1
  den=1
  for i in range(r):
    num=num*(n-i)
    den=den*(r-i)
    res=num/den
  return res
calnCr(5,4)

# Type 2 : Problem given row number generate the sequence of number for that columnn
# Row number=6
# TC:O(n*r)
n=6
def calnCr(n,r):
  num=1
  den=1
  res=1
  for i in range(r):
    num=num*(n-i)
    den=den*(r-i)
    res=num//den
  return res
for col in range(1,n+1):
  print(calnCr(n-1,col-1))

# Type 2 Method 2
ans=[1]
res=1
n=6
for i in range(1,n):
  res=res*(n-i)
  res=res//i
  ans.append(res)
print(ans)

# Type 3 given n print pascal trangle
#TC: O(n*n*n)
n=6
ans=[]
for row in range(1,n+1):
  temp=[]
  for col in range(1,row+1):
    temp.append(calnCr(row-1,col-1))
  ans.append(temp)
print(ans)

# Type 3 Method 3
def genRow(n):
  res=1
  ansRow=[1]
  for i in range(1,n):
    res=res*(n-i)
    res=res//i
    ansRow.append(res)
  return ansRow
def pascalTrangle(n):
  ans=[]
  for i in range(1,n+1):
    ans.append(genRow(i))
  return ans
pascalTrangle(6)

"""# **Majority Element II**"""

# Find the number which occure more than n/3
# Method 1
# TC: O(n^2)
# SC: O(1)
arr=[1,1,1,3,3,2,2,2]
n=len(arr)
gt=n//3
for i in range(n):
  count=0
  for j in range(i,n):
    if arr[i]==arr[j]:
      count+=1
  if count>gt:
    print(arr[i])

# Method 2
# TC: O(nlog(n))
# SC: O(n)

arr=[1,1,1,3,3,2,2,2]
n=len(arr)
gt=n//3
d={}
for i in arr:
  if i not in d:
    d[i]=1
  else:
    d[i]+=1
for k,v in d.items():
  if v>gt:
    print(k)

"""# **Sum 3 number of given array is Zero**"""

# Method 1
# TC:O(n^3)
# SC:O(number of triplet)
arr=[-1,0,1,2,-1,-4]
n=len(arr)
ans=set()
for i in range(n):
  for j in range(i+1,n):
    for k in range(j+1,n):
      if arr[i]+arr[j]+arr[k]==0:
        temp=[arr[i],arr[j],arr[k]]
        temp.sort()
        ans.add(tuple(temp))
print(ans)

# Method 2
# TC:O(n^2 log(size of set))
# SC:O(n) + nlog(n)
arr=[-1,0,1,2,-1,-4]
n=len(arr)
ans=set()
for i in range(n):
  d=set()
  for j in range(i+1,n):
    third=-(arr[i]+arr[j])
    if third in d:
      temp=[arr[i],arr[j],third]
      temp.sort()
      ans.add(tuple(temp))
    d.add(arr[j])
print(ans)

# Method 3
# TC:O(nlog(n)+n^2)
# SC:O(number of unique triplet)
arr=[-1,0,1,2,-1,-4]
arr.sort()
n=len(arr)
ans=set()
for i in range(n):
  if i>0 and arr[i]==arr[i-1]:
    continue
  j=i+1
  k=n-1
  while(j<k):
    sum=arr[i]+arr[j]+arr[k]
    if sum<0:
      j+=1
    elif sum>0:
      k-=1
    else:
      temp=[arr[i],arr[j],arr[k]]
      ans.add(tuple(temp))
      j+=1
      k-=1
      while(j<k and arr[j]==arr[j-1]):
        j+=1
      while(j<k and arr[k]==arr[k+1]):
        k+=1
print(ans)

"""# **Sum 4 number of given array is Zero**"""

# Method 1
# TC:O(n^4)
# SC:O(number of ans)
arr=[-1,0,1,2,-1,-4]
n=len(arr)
target=0
ans=set()
for i in range(n):
  for j in range(i+1,n):
    for k in range(j+1,n):
      for l in range(k+1,n):
        if arr[i]+arr[j]+arr[k]+arr[l]==target:
          temp=[arr[i],arr[j],arr[k],arr[l]]
          temp.sort()
          ans.add(tuple(temp))
print(ans)

# Method 2
# TC:O(n^3 + log(set dependent))
# SC:O(n) + O(unique quad)*2
arr=[-1,0,1,2,-1,-4]
n=len(arr)
target=0
ans=set()
for i in range(n):
  for j in range(i+1,n):
    s=set()
    for k in range(j+1,n):
      fourth=target-(arr[i]+arr[j]+arr[k])
      if fourth in s:
        temp=[arr[i],arr[j],arr[k],fourth]
        temp.sort()
        ans.add(tuple(temp))
      s.add(arr[k])
print(ans)

"""# **Largest Subarray with Zero Sum**
Important
"""

# TC : O(n^2+O(len(subarray)))
arr=[15,-2,2,-8,1,7,10,23]
n=len(arr)
subarray=[]
for i in range(n):
  for j in range(i+1,n+1):
    subarray.append(arr[i:j])
res=[]
for i in subarray:
  if sum(i)==0:
    res.append(len(i))
print(max(res))

# Put the previous sum in hasmap and find the length
#TC O(n)+nlogn
arr=[15,-2,2,-8,1,7,10,23]
n=len(arr)
maxi=0
sum=0
d={}
for i in range(n):
  sum=sum+arr[i]
  if sum==0:
    maxi=i+1
  else:
    if d.get(sum)!=None:
      maxi=max(maxi,i-d.get(sum))
    else:
      d[sum]=i
print(maxi)

"""# **Number of Subarrays with xor K**"""

# Method 1

arr=[4,2,2,6,4]
n=len(arr)
sub_arr=[]
x=0
for i in range(n):
  for j in range(i+1,n+1):
    sub_arr.append(arr[i:j])
#print(sub_arr)
for lst in sub_arr:
  Xor=0
  for i in lst:
    Xor=Xor^i
    #print(Xor)
  if Xor==6:
    print(lst)

# Method 2
arr=[4,2,2,6,4]
n=len(arr)
count=0
for i in range(n):
  for j in range(i,n):
    Xor=0
    for k in range(i,j+1):
      Xor=Xor^arr[k]
    if Xor==6:
      count+=1
print(count)

# Method 3
# TC:O(n^2)
arr=[4,2,2,6,4]
n=len(arr)
count=0
for i in range(n):
  Xor=0
  for j in range(i,n):
    Xor=Xor^arr[j]
    if Xor==6:
      count+=1
print(count)

from collections import defaultdict
arr=[4,2,2,6,4]
n=len(arr)
xr=0
d=defaultdict(int)
d[xr]=1
cnt=0
k=6
for i in range(n):
  xr=xr^arr[i]
  x=xr^k
  cnt+=d[x]
  d[xr]+=1
print(cnt)

# Method 4
# TC: O(n)+log(n)
# SC: O(n)
arr=[4,2,2,6,4]
n=len(arr)
xr=0
k=6
d={}
for i in range(n):
  xr=xr^arr[i]
  if xr^k == k:
    d[xr^k]+=1
  else:
    d[xr^k]=i
# print(d)
for k,v in d.items():
  if k==0:
    print(v)

"""# **Generate all Subarry of an Array**
Important
"""

# Method 1
# TC: O(n^3)
arr=[1,2,3]
n=len(arr)
sub_arr=[[]]
for i in range(n):
  for j in range(i,n):
    sub_arr.append(arr[i:j+1])
print(sub_arr)

# Method 2
# TC: O(n^3)
lst=[1,2,3]
[lst[i:j] for i in range(len(lst)) for j in range(i + 1, len(lst) + 1)]

def sublists(lst, index=0, current=[]):
    if index == len(lst):
        print(current)
        return
    sublists(lst, index+1, current)
    sublists(lst, index+1, current + [lst[index]])

lst = [1, 2, 3]
sublists(lst)

# Method 2
# TC: O(n^3)
arr=[1,2,3]
n=len(arr)
sub_arr=[]
for i in range(n):
  for j in range(i,n):
    for k in range(i,j+1):
      print(arr[k],end='')
    print()

# This method is applicable when we perform any operation of subarray
# TC: O(n^3)
arr=[1,2,3]
n=len(arr)
sub_arr=[]
for i in range(n):
  for j in range(i,n):
    print(arr[j],end='')
  print()

"""# **Merge Overlapping Intervals**"""

# Method 1
# TC: nlog(n)+O(2n)
# SC: O(n)
arr=[(1,3),(2,6),(8,9),(9,11),(8,10),(2,4),(15,18),(16,17)]
arr.sort()
n=len(arr)
ans=[]
for i in range(n):
  start=arr[i][0]
  end=arr[i][1]
  if ans and end<=ans[-1][1]:
    continue
  for j in range(i+1,n):
    if arr[j][0]<=end:
      end=max(end,arr[j][1])
    else:
      break
  ans.append((start,end))
print(ans)

# Method 2
# TC: nlog(n)+O(n)
# SC: O(n)
arr=[[1,3],[2,6],[8,9],[9,11],[8,10],[2,4],[15,18],[16,17]]
arr.sort()
n=len(arr)
ans=[]
for i in range(n):
  if not ans or arr[i][0]>ans[-1][1]:
    ans.append(arr[i])
  else:
    ans[-1][1]=max(ans[-1][1],arr[i][1])
print(ans)

"""# **Merge Sorted Arrays Without Extra Space**"""

# Method 1
# TC: O(n1+n2)
# Sc: O(n1+n2)
arr1=[1,3,5,7]
arr2=[0,2,6,8,9]
n1=len(arr1)
n2=len(arr2)
ans=[]
i,j=0,0
while i<n1 and j<n2:
  if arr1[i]<arr2[j]:
    ans.append(arr1[i])
    i+=1
  else:
    ans.append(arr2[j])
    j+=1
while i<n1:
  ans.append(arr1[i])
  i+=1
while j<n2:
  ans.append(arr2[j])
  j+=1
print(ans)

# Method 2
# TC: O(n1+n2)
# Sc: O(n1+n2)
arr1=[1,3,5,7]
arr2=[0,2,6,8,9]
n=len(arr1)
m=len(arr2)
left=n-1
right=0
while left<0 and right<n:
  if arr1[left]>arr2[right]:
    temp=arr1[left]
    arr1[left]=arr2[right]
    arr2[right]=temp
    left-=1
    right+=1
  else:
    break

print(arr1,arr2)

# Method 3
# TC: O(n1+n2)
# Sc: O(n1+n2)
import math
arr1=[1,3,5,7]
arr2=[0,2,6,8,9]
n=len(arr1)
m=len(arr2)
length=m+n
gap=math.ceil(length/2)
while gap>0:
  left=0
  right=left+gap
  while right<length:
    if left<n and right>=n:
      pass
    elif left>=n:
      pass

"""# **Find the Missing and Repeating Number**"""

# Method 1
# Given the vlaue of n and array to find the missing number which is not present in array and repating checking all value till n
n=int(input())
arr=[4,3,6,2,1,1]
temp=arr
l=[i for i in range(1,n+1)]
for i in range(len(l)):
    if l[i] in arr:
      temp.remove(l[i])
    else:
      temp.append(l[i])
print(temp)

# Method 2
# TC : O(n^2)
n=int(input())
arr=[4,3,6,2,1,1]
repating=-1
missing=-1
for i in range(1,n+1):
  count=0
  for j in range(len(arr)):
    if arr[j]==i:
      count+=1
  if count==2:
    repating=i
  elif count==0:
    missing=i
  if repating==-1 and missing==-1:
    break
print(missing,repating)

# Method 2
n=int(input())
arr=[4,3,6,2,1,1]
d={}
for i in arr:
  if i not in d:
    d[i]=1
  else:
    d[i]+=1
for i in range(1,n+1):
  if i not in d:
    print(i)
for k,v in d.items():
  if v==2:
    print(k)

# Method 3
# TC: O(2n)
# SC: O(n)
n=int(input())
arr=[4,3,6,2,1,1]
has_arr=[0]*(n+1)
repating=-1
missing=-1
for i in range(len(arr)):
  has_arr[arr[i]]+=1
for i in range(1,n+1):
  if has_arr[i]==2:
    repating=i
  elif has_arr[i]==0:
    missing=i
  if repating==-1 and missing==-1:
    break
print(repating,missing)

# Method 4
# TC: O(n)
# SC: O(1)
arr=[4,3,6,2,1,1]
n=len(arr)
sn=n*(n+1)/2
s2n=(n*(n+1)*(2*n+1))/6
s=0
s2=0
for i in range(n):
  s+=arr[i]
  s2+=arr[i]*arr[i]
val1=s-sn #x-y
val2=s2-s2n #x^2-y^2
val2=val2/val1
x=int((val1+val2)/2)
y=int(x-val1)
print(x,y)

"""# **Count Inversions in an Array**"""

# left elemnet of pair must be less than the right element
# Method 1
# TC: O(n^2)
# SC: O(1)
arr=[5,3,2,4,1] # (5,3),(5,2),(5,4),(5,1),(3,2),(3,1),(2,1),(4,1)
n=len(arr)
count=0
for i in range(n):
  for j in range(i,n):
    if arr[i]>arr[j]:
      count+=1
print(count)

"""# **Reverse Pairs**"""

# Method 1
# TC: O(n^2)
# SC: O(1)
arr=[40,25,19,12,9,6,2]
n=len(arr)
sub_arr=[]
count=0
for i in range(n):
  for j in range(i+1,n):
    if arr[i]>2*arr[j]:
      count+=1
print(count)

"""# **Maximum Product Subarray**"""

# Method 1
# TC: O(n^3)
# SC: O(1)
import math
arr=[2,3,-2,4]
n=len(arr)
max_prod=-math.inf
for i in range(n):
  for j in range(i,n):
    prod=1
    for k in range(i,j):
      prod=prod*arr[k]
    max_prod=max(max_prod,prod)
print(max_prod)

arr=[2,3,-2,4]
n=len(arr)
max_prod=0
sub_arr=[]
for i in range(n):
  for j in range(i,n):
    sub_arr.append(arr[i:j+1])
prod=[]
# print(sub_arr)
for i in sub_arr:
  mul=1
  for j in i:
    mul*=j
  prod.append(mul)
print(max(prod))

# Method 2
# TC: O(n^3)
# SC: O(1)
import math
arr=[2,3,-2,4]
n=len(arr)
max_prod=-math.inf
for i in range(n):
  prod=1
  for j in range(i,n):
    prod=prod*arr[j]
    max_prod=max(max_prod,prod)
print(max_prod)



